"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypescriptMutator = exports.MUTATORS_TOKEN = exports.typescriptMutatorFactory = void 0;
const plugin_1 = require("@stryker-mutator/api/plugin");
const ts = require("typescript");
const flatMap = require("lodash.flatmap");
const tsHelpers_1 = require("./helpers/tsHelpers");
const mutator_1 = require("./mutator");
function typescriptMutatorFactory(injector) {
    return injector.provideValue(exports.MUTATORS_TOKEN, mutator_1.nodeMutators).injectClass(TypescriptMutator);
}
exports.typescriptMutatorFactory = typescriptMutatorFactory;
typescriptMutatorFactory.inject = plugin_1.tokens(plugin_1.commonTokens.injector);
exports.MUTATORS_TOKEN = 'mutators';
class TypescriptMutator {
    constructor(options, mutators) {
        this.options = options;
        this.mutators = mutators;
    }
    mutate(inputFiles) {
        const tsConfig = tsHelpers_1.getTSConfig(this.options);
        const mutants = flatMap(inputFiles, (inputFile) => {
            const sourceFile = tsHelpers_1.parseFile(inputFile, tsConfig && tsConfig.options && tsConfig.options.target);
            return this.mutateForNode(sourceFile, sourceFile);
        });
        return mutants;
    }
    mutateForNode(node, sourceFile) {
        if (shouldNodeBeSkipped(node)) {
            return [];
        }
        else {
            const targetMutators = this.mutators.filter((mutator) => mutator.guard(node));
            const mutants = flatMap(targetMutators, (mutator) => mutator.mutate(node, sourceFile));
            node.forEachChild((child) => {
                // It is important that forEachChild does not return a true, otherwise node visiting is halted!
                mutants.push(...this.mutateForNode(child, sourceFile));
            });
            return mutants;
        }
    }
}
exports.TypescriptMutator = TypescriptMutator;
TypescriptMutator.inject = plugin_1.tokens(plugin_1.commonTokens.options, exports.MUTATORS_TOKEN);
const shouldNodeBeSkipped = (node) => {
    return (node.kind === ts.SyntaxKind.InterfaceDeclaration ||
        (node.modifiers !== undefined && node.modifiers.some((modifier) => modifier.kind === ts.SyntaxKind.DeclareKeyword)));
};
//# sourceMappingURL=TypescriptMutator.js.map