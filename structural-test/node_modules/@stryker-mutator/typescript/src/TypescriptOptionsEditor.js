"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const os = require("os");
const path = require("path");
const plugin_1 = require("@stryker-mutator/api/plugin");
const ts = require("typescript");
const util_1 = require("@stryker-mutator/util");
const tsHelpers_1 = require("./helpers/tsHelpers");
// Override some compiler options that have to do with code quality. When mutating, we're not interested in the resulting code quality
// See https://github.com/stryker-mutator/stryker/issues/391 for more info
const COMPILER_OPTIONS_OVERRIDES = Object.freeze({
    allowUnreachableCode: true,
    noUnusedLocals: false,
    noUnusedParameters: false,
});
class TypescriptOptionsEditor {
    constructor(log) {
        this.log = log;
    }
    edit(strykerConfig, host = ts.sys) {
        this.loadTSConfig(strykerConfig, host);
    }
    loadTSConfig(strykerConfig, host) {
        if (strykerConfig.tsconfigFile) {
            const tsconfigFileName = path.resolve(strykerConfig.tsconfigFile);
            this.log.info(`Loading tsconfig file ${tsconfigFileName}`);
            const tsconfig = this.readTypescriptConfig(tsconfigFileName, host);
            if (tsconfig) {
                strykerConfig.tsconfig = this.overrideOptions(tsconfig);
            }
        }
        else {
            this.log.debug("No '%s' specified, not loading any config", util_1.propertyPath('tsconfigFile'));
        }
    }
    overrideOptions(tsConfig) {
        tsConfig.options = Object.assign({}, tsConfig.options, COMPILER_OPTIONS_OVERRIDES);
        tsConfig.fileNames = tsConfig.fileNames.map(tsHelpers_1.normalizeFileFromTypescript);
        return tsConfig;
    }
    readTypescriptConfig(tsconfigFileName, host) {
        const configFileBase = tsHelpers_1.normalizeFileForTypescript(path.dirname(tsconfigFileName));
        const configFileText = fs.readFileSync(tsconfigFileName, 'utf8');
        const tsconfigFileNameNormalizedForTypeScript = tsHelpers_1.normalizeFileForTypescript(tsconfigFileName);
        const parseResult = ts.parseConfigFileTextToJson(tsconfigFileNameNormalizedForTypeScript, configFileText);
        if (parseResult.error) {
            const error = ts.formatDiagnostics([parseResult.error], diagnosticsHost(configFileBase));
            throw new Error(`Error while loading tsconfig file '${tsconfigFileName}': ${error}`);
        }
        else {
            const tsconfig = ts.parseJsonConfigFileContent(parseResult.config, host, configFileBase, { project: configFileBase }, tsconfigFileNameNormalizedForTypeScript);
            if (tsconfig.errors.length) {
                const error = ts.formatDiagnostics(tsconfig.errors, diagnosticsHost(configFileBase));
                this.log.error(`Error while loading tsconfig file '${tsconfigFileName}': ${error}`);
            }
            return tsconfig;
        }
        function diagnosticsHost(configFileBase) {
            return {
                getCanonicalFileName: (fileName) => path.resolve(fileName),
                getCurrentDirectory: () => configFileBase,
                getNewLine: () => os.EOL,
            };
        }
    }
}
exports.default = TypescriptOptionsEditor;
TypescriptOptionsEditor.inject = plugin_1.tokens(plugin_1.commonTokens.logger);
//# sourceMappingURL=TypescriptOptionsEditor.js.map