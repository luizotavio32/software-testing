"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ts = require("typescript");
const tsHelpers_1 = require("../helpers/tsHelpers");
const NodeMutator_1 = require("./NodeMutator");
/**
 * Type guard for seperating default clause from case clauses.
 */
function isDefaultClause(node) {
    return node.kind === ts.SyntaxKind.DefaultClause;
}
class ConditionalExpressionMutator extends NodeMutator_1.default {
    constructor() {
        super(...arguments);
        this.name = 'ConditionalExpression';
    }
    guard(node) {
        return (node.kind === ts.SyntaxKind.BinaryExpression ||
            node.kind === ts.SyntaxKind.CaseClause ||
            node.kind === ts.SyntaxKind.DefaultClause ||
            node.kind === ts.SyntaxKind.DoStatement ||
            node.kind === ts.SyntaxKind.ForStatement ||
            node.kind === ts.SyntaxKind.IfStatement ||
            node.kind === ts.SyntaxKind.WhileStatement);
    }
    isInvalidParent(parent) {
        switch (parent.kind) {
            case ts.SyntaxKind.IfStatement:
            case ts.SyntaxKind.ForStatement:
            case ts.SyntaxKind.WhileStatement:
            case ts.SyntaxKind.DoStatement:
            case ts.SyntaxKind.LiteralType:
            case ts.SyntaxKind.CaseClause:
            case ts.SyntaxKind.DefaultClause:
                return true;
            default:
                return false;
        }
    }
    isInvalidOperator(operatorToken) {
        switch (operatorToken.kind) {
            case ts.SyntaxKind.PlusToken:
            case ts.SyntaxKind.MinusToken:
            case ts.SyntaxKind.SlashToken:
            case ts.SyntaxKind.AsteriskToken:
            case ts.SyntaxKind.PercentToken:
            case ts.SyntaxKind.EqualsToken:
                return true;
            default:
                return false;
        }
    }
    identifyReplacements(node, sourceFile) {
        if (node.kind === ts.SyntaxKind.DoStatement || node.kind === ts.SyntaxKind.WhileStatement) {
            return [{ node: node.expression, replacement: 'false' }];
        }
        else if (node.kind === ts.SyntaxKind.ForStatement) {
            if (node.condition) {
                return [{ node: node.condition, replacement: 'false' }];
            }
            else {
                // No node to replace. Happens when for statement is defined as `for(let i=0;;i++)`
                // Replace the entire node
                const replacement = tsHelpers_1.printNode(ts.createFor(node.initializer, ts.createFalse(), node.incrementor, node.statement), sourceFile);
                return [{ node, replacement }];
            }
        }
        else if (node.kind === ts.SyntaxKind.IfStatement) {
            return [
                { node: node.expression, replacement: 'true' },
                { node: node.expression, replacement: 'false' },
            ];
        }
        else if (node.kind === ts.SyntaxKind.CaseClause || node.kind === ts.SyntaxKind.DefaultClause) {
            // if not a fallthrough case
            if (node.statements.length > 0) {
                const clause = isDefaultClause(node) ? ts.createDefaultClause([]) : ts.createCaseClause(node.expression, []);
                const replacement = tsHelpers_1.printNode(clause, sourceFile);
                return [{ node, replacement }];
            }
            else {
                return [];
            }
        }
        else {
            if ((node.parent && this.isInvalidParent(node.parent)) ||
                (node.parent && node.parent.parent && this.isInvalidParent(node.parent.parent)) ||
                this.isInvalidOperator(node.operatorToken)) {
                return [];
            }
            return [
                { node, replacement: 'false' },
                { node, replacement: 'true' },
            ];
        }
    }
}
exports.default = ConditionalExpressionMutator;
//# sourceMappingURL=ConditionalExpressionMutator.js.map